# 设计模式基本要素
1. 模式名称
2. 问题
3. 解决方案
4. 效果

# MVC架构
- model: 应用对象
- view： 屏幕上的显示
- controller： 用户界面对用户输入的响应方式

## 特征
- 通过订购。通知协议来分离试图和模型
- 视图可以嵌套（通过view的子类）
- 允许在不改变视图的外观的情况下改变视图对用户输入的响应（修改controller）
- 主要由observer，composite和strategy模式组成，也包含factory method和decorator

# 设计模式分类
## 创建型(与对象创建有关)
- factory method
- abstract factory
- builder
- prototype
- singleton

## 结构型（处理类或对象的组合）
- adapter
- bridge
- composite
- decorator
- facade
- flyweight
- proxy

## 行为型（对象之间的交互和职责分配）
- interpreter
- template method
- chain of responsibility
- command
- iterator
- mediator
- memento
- observer
- state
- strategy
- visitor

# 相关概念
- 接口： 对象操作所定义的所有操作型构的集合叫对象的接口
- 类型： 表示特定接口的一个名字
- 子类，父类
- 动态绑定： 发送的请求直到运行时刻才收到具体实现的约束
- 多态： 由于动态绑定， 可以在运行时刻彼此替换有相同接口的对象
- 类的实例
- 抽象类，抽象操作，具体类
- 混入类（mixin class）： 给其他类提供可选择的接口或功能的类，要求多继承
## 类（class） 和类型（type）的区别
- 类定义对象怎么实现的
- 类型只与接口有关
- 当我们说一个对象是一个类的实例时，指该对象支持类所定义的接口
  
## 类继承与接口继承
- 类继承： 代码和表示的共享机制
- 接口继承： 一个对象什么时候能用来替代另一个对象

## 对接口编程，而不是对实现编程
## 优先使用对象组合而不是类继承
# 复用机制
## 继承与组合
- 类继承
  - 白箱复用（white reuse)，父类的内部细节对子类课件
  - 编译时刻静态定义，可直接使用
  - 无法时刻改变从父类继承的实现
  - 继承对子类揭示了父类的实现细节，破坏了封装性
- 组合： 
  - 要求被组合对象有良好定义的接口。 黑箱复用，对象内部细节不可见
  - 不会破坏封装性
  - 只要类型一致，运行时刻可以用一个对象类替代另一个对象，较少依赖关系

- 委托
  - 一种组合方式，接收请求的对象将操作委托给他的继承者
  - 便于运行时刻组合对象操作以及改变这些操作的组合方式
  - 比静态更难于理解
  - 运行低效
- 参数化类型（templates)
  - 允许定义一个类型时并不指定该类型所用到的去其他所有类型

# 关联运行时刻和编译时刻的结构
- 面向对象程序在运行时刻的结构与代码结构相差较大
- 聚合（aggregation）
  - 一个对象拥有另一个对象或对另一个对象负责
  - 聚合对象和所有者具有相同的生命周期
- 相识（acquaintance）
  - 一个对象仅仅知道另一个对象
  - 也成为关联或引用
  - 松散的耦合关系

# 设计一个文档编辑器
1. 文档结构
2. 格式化
3. 修饰用户界面
4. 支持多种视感标准
5. 支持多种窗口系统
6. 用户操作
7. 拼写检查和连字符

## 文档结构
- 保持文档物理结构
- 可视化生成和显示文档
- 根据显示位置来映射文档内部表示的元素
- 一致对待文本和图形
- 不应该过分强调单个元素和元素组之间的区别
### 递归组合
- 由较简单的元素主见建立复杂的元素


![picture 1](images/90cbaae552cd16f26a1fb4a732e88408907677d62cc0020dc5cbe2315de021c8.png)  

- 对象需要相应的类
- 一致性对待这些对象，类必须有兼容的接口（继承）

### 图元（Glyph)
- 出现在文档结构中的所有对线定义一个抽象类图元
- 子类既包含图形元素，也包含结构元素


![picture 2](images/7fe5b8483243fb7af91c9aec1374199f0dcea5e6dd53babb531094dadbc704a0.png)  
![picture 3](images/746c84a0963d373415213ca71825df7874397a99db01ee2f13ca18b0581a65de.png)  

- 子类为了在窗口上表示自己，重新定义了draw操作
- 要一个公共的接口来添加删除和访问这些子图元

## 格式化（formatting）
- 将一个图元集合分解为若干行，格式化 = 分行（linebreaking）

### 封装格式化算法
- 最好将它彻底独立于文档结构之外
- 理想情况下，我们可以自由增加一个Glyph子类而不用考虑格式化算法
- 最好在运行时刻，至少在编译时刻可以方便改变算法

### compositor 和 composition
- 为格式化算法的对象定义一个compositor类
- compositor格式化的是称为compositor的图元的各个子图元

![picture 10](images/de12e3b73677db6432690dbb3f5ea1de46d92d09d46f5b22541081724cf19dc1.png)  

- composition格式化时，调用compositor的compose操作。compositor一个遍历composition各个子图元，根据分行算法插入新的行和列图元

### 策略模式
- 目的是在对象中封装算法
- 为strategy和他的环境设计足够通用的接口，以支持一系列的算法，不必为了支持一个新的算法而改变strategy或它的环境

## 修饰用户界面
- 不应该用继承的方式加到用户界面，其他用户界面对象不知道存在这些修饰

### 透明围栏
- 把修饰本身看作对象： 图元和边界
- 一致对待图元，而不是关心图元是否有边界： border作为glyph的子类

### monograph
- glyph的子类，作为其修饰作用的图元的抽象类

![picture 11](images/06ac600ce24e76e0496c77b7be2c5a371cb20e8b63e9b7e932f1cad478497bc6.png)  

### decorator模式
- 修饰指给一个对象增加职责的事务

## 支持多种视感标准
- 跨硬件和软件平台的可移植性
- 必须符合各个平台的用户界面风格
- 可以通过抽象对象创建过程来达到要求

### 工厂类和产品类
- 减少直接new对象


![picture 12](images/c9d60dafa1f5d36e5ee49852feaa79ebeaba018092c18fbb85e2654c8a91f588.png)  
![picture 13](images/2f09779d2aed944319ec3eaac8850fff55d65969dd91d1d7e8b31bd11fef550f.png)  

- guifactory的实例可以使全局变量，一个众所周知的类的成员，甚至局部变量

### abstract factory 模式
- factory和product是abstract factory的主要参与者
- 该模式描述了如何在不直接实例化类的情况下就创建一系列相关的产品对象

## 支持多种窗口系统
### 不能继续使用abstract factory
- 使用abstract factory需要假设我们能为每一个视感标准定义具体的窗口组件类。也就是能从抽象产品导出具体产品
- 我们不能实现自己的非标准窗口系统
- 我们可对不同窗口系统做一个统一的抽象，使之符合公共的接口

### 封装实现依赖关系

![picture 14](images/f4c8470c03ab94552d70e7c98560fe701601906292c5aa9f64807a7b6a61d86d.png)  

- windows是一个抽象类，具体子类支持用户用到的不同种类的窗口
- 改进前

![picture 15](images/edf1926b9415fe3d69191d4cdb7478016c6dcd2aec77be84248ceba8536bbcf9.png)  


### window和windowimpl
- 定义一个windowimpl来隐藏不同窗口的具体实现
- 通过windowimpl类可以避免对窗口系统的直接依赖，让window层保持相对较小并且稳定

![picture 16](images/238a36af45c909474e3c545afe7b296f10a18666969be2f9f9857151e89db389.png)  

- 怎么判断应该使用什么窗口系统，windowimpl子类？ 抽象工厂


### bridge模式
- 允许分类的类层次一起工作，使我们创建了两个分离的类层次，一个支持窗口的逻辑概念，一个描述了窗口的不同实现


## 用户操作
- 我们希望多个用户界面对应一个操作
- 我们想要访问这些功能，又不希望在用户界面类和他的实现之间建立过多依赖关系

### 封装一个请求操作
- MenuItem子类： 响应客户请求
- 用对象来参数化menuitem，通过集成扩充和复用请求实现
- 在command对象中封装每一个请求

### command类和其子类

![picture 17](images/7f065d1b6b4ac3b8823072afb1d822fd441d3ceabf6af24551fcc75ba03ce2a7.png)  

### 撤销和重做
- unexecute

### 命令历史记录
### command模式
- 描述了怎样封装请求，也描述了一致性的发送请求的接口
- 可以委托，也可以不委托

## 拼写检查和断字处理
- 希望支持多种算法
- 避免功能与文档结构的耦合

### 访问分散的信息
- 由于检查算法不同，需要访问机制能容纳不同的数据结构，以及不同的遍历方法

### 封装访问和遍历
- 只有图元自己知道它所使用的数据结构，接口不应该偏向于某个结构，因此数组比链表更好
- 由于遍历方法可能有变，需要封装变化的概念： 引入iterators的对象。

### iterators类和子类

![picture 18](images/0d69ab2c0ac18a5037cdffd87391b8a9f0b2049a7bb32575da227d8552be44a8.png)  

- 我们只需创建iterators子类，并增加一个新的遍历算法

### iterators模式
- 抽象了遍历算法， 对客户隐藏了他所遍历对象的内部结构

### 遍历和遍历中的动作
- 将分析与遍历分开
- 一个给定的分析必须能区分不同种类的图元

### 封装分析
- 封装分析，把分析的实例和对应iterators结合起来

### visitor模式
- 访问者泛指遍历过程中访问被被遍历对象并做适当操作的一类对象
- 该模式最适合于你想对一个稳定类结构的对象做许多不同事情的情况
- 如果给类结构增加了一个子类，就必须更新所有访问者的接口及对应visit操作
- 我们比较多的是增加新的分析方法而不是增加新的图元

# 创建型模式
- 抽象了实例化过程
- 创建什么，谁来创建，如何创建，何时创建
## abstract factory 抽象工厂
### 意图
- 提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类
### 动机
- 保证视感风格标准间的可移植性

![picture 21](images/4ca4708dfebfdb7e2b8e1c38239bf8531d26a3a767471c85a7cd67b257f0e8da.png)  

### 适用性
- 一个系统要独立于他的产品的创建，组合和表示
- 一个系统要由多个产品系列中的一个来配置
- 要强调一系列相关的产品对象的设计一边进行联合使用
- 提供一个产品类库，而指向显示它们的接口而不是实现

### 结构

![picture 20](images/e152c94d40d658adf985d6c29a00a5f389fee6c906d619b6e574e46d29957b4f.png)  

### 参与者
- abstractfactory： 声明一个创建关键抽象产品对象的操作接口
- concretefactory： 实现创建具体产品对象的操作
- abstractproduct： 为一类产品对象声明一个接口
- concreteproduct： 定义一个将被相应的具体工厂创建的产品对象，实现abstractfactory接口
- client： 经使用由abstractfactory和abstractproduct类声明的接口
### 协作
- 运行时刻创建一个concretefactory的实例。为不同的产品对象，使用不同的具体工厂

### 效果
1. 分离了具体的类，将客户和类的实现分离
2. 易于交换产品系列，一个具体工厂类只在一个应用中出现一次，初始化的时候
3. 利于产品的一致性，一个应用一次只能使用同一个系列中的产品
4. 难以支持新种类的产品

### 相关模式
1. abstractfactory类常用factory method实现，也可以用prototype实现
2. 一个具体的工厂通常是一个singleton
## builder 生成器
### 意图
- 将一个复杂对象的构建与他的表示分离，是同样的构建过程可以创建不同的表示
## factory method 工厂方法
### 意图
- 定义一个用于创建对象的接口，让子类决定实例化那个对象。将一个类的实例化延迟到子类
### 动机
- application类不能预测到哪个document子类将被实例化
- 框架必须实例化类，但他只知道不能被实例化的抽象类。
![picture 22](images/8b52f0ff8c66684211e431e72a0d30c35bc8790e90a50fa25e5945a47975044e.png)  

### 适用性
- 当一个类不知道他说必须创建的对象的类的时候
- 当一个类希望由他的子类来指定他所创建的对象的时候
- 当类将创建对象的职责委托给他多个帮助子类的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

### 结构
![picture 23](images/03af2ee9936282930877e3b3fe428230d5b28ee73e6727d32900dfa672db8538.png)  

### 参与者
- product： 定义工厂方法所创建的对象的接口
- concreteproduct： 实现product接口
- creator: 声明工厂方法，该方法返回一个product类型的对象。creator也可以定义一个工厂方法的缺省实现，返回一个缺省的concreteproduct对象，可以调用工厂方法以创建一个product对象
- concretecreator： 重定义工厂方法以返回一个concreteproduct实例

### 协作
- creator 依赖于他的子类来定义工厂方法，所以返回一个适当的concreteproduct实例

### 效果
- 代码仅处理product接口，因此可以和用户定义的任何convreteproduct类一起使用
- 用户可能为了创建一个特定的concreteprodcut对象就不得不创建creator子类

### 相关模式
- abstractfactory经常用工厂方法来实现
- 工厂方法通常扎起templatemethods中被调用
- prototype不需要创建creator子类，但通常要求一个针对product类的initialize操作。

## prototype 原型
## singleton 单例
### 意图
- 保证一个类仅有一个实例，并提供一个访问它的全局访问点

### 适用性
- 当类只能有一个实例而且客户可以从一个众所周知的访问点访问他时
- 当这个唯一实例应该是通过子类化课扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时

### 结构
![picture 1](images/921a48f26ae047bacfd9ca7c2ba4dcb603e41e5e075d0a85973bf6c675b55d54.png)  

### 协作
- 客户只能通过singleton的instance操作访问一个singleton的实例

### 效果
- 对唯一实例的受控访问
- 缩小名空间
- 允许对操作和表示的精化
- 允许可变数目的实例
- 比类操作更灵活

### 相关应用 
- abstract factory， builder，prototype都可以用单例实现

# 结构型模式
- 设计如何组合类和对象以获得更大的结构
## adapter 适配器
## bridge 桥接
## composite 组合
## decorator 装饰
### 意图
- 动态的给一个对象增加一些额外的职责，相比生成子类更加灵活

### 动机
- 有时需要给某个对象而不是整个类添加一些功能
- 继承不够灵活
- 装饰对使用组件的客户透明
![picture 2](images/903a8982a5984a9e200e283afe72a2d00615d952ebbe3ecc19234f45f589f742.png)  

### 适用性
- 在不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责
- 处理那些可以被撤销的职责
- 当不能蔡总生成子类的方法进行扩充时，比如子类数目爆炸性增长

### 结构
![picture 3](images/84e2586a993493f3e68ec1b00b95b855c1bc7ca6a0db138bec9bb1ce7fde3003.png)  

### 参与者
- component： 定义一个对象接口，可以给这些对象动态的增加职责
- concretecomponent： 定义一个对象，可以给这个对象增加一些职责
- decorator： 维持一个纸箱component对象的指针，并定义一个与component接口一致的接口
- concretedecorator： 向组件添加职责

### 协作
- decorator将请求转发给他的component对象，并有可能在转发前后附加一些动作。

### 效果
- 比静态继承更加简洁，不会产生许多新的类
- 避免在层次结构高层的类有太多特征，不需要在一个复杂的类中支持所有可预见的特征
- decorator与他的component不一样，装饰时不应该依赖对象标识
- 有许多小对象，排错困难

### 实现
- 装饰对象的接口必须与他所装饰的component的接口是一致的，多有的concretedecorator必须要有一个公共的父类
- 保持component简单
![picture 4](images/b79beb7ed113c20689839a8eb05bbc3ff94bb5909422acfa7270d156aec87eea.png)  

### 相关模式
- adapter接口： 不同点在于装饰仅改变对象的职责而不改变它的接口，而适配器讲给对象一个新的接口
- composite模式： 装饰的目的是在于添加额外职责而不在于对象聚集
- strategy模式： strategy模式可以改变对象的内核

## facade 外观
## flyweight 享元
## proxy 代理

# 行为模式
- 算法和对象间的职责分配，通信模式
## chain of responsibility 职责链
### 意图
- 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，沿职责链传递请求，知道有对象处理它为止
### 动机
- 根据普遍性，即从最特殊到最普遍的顺序来组织帮助信息
- 从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者
- 提交请求的对象并不明确知道哪一个对象会处理它，有一个隐式的接收者（implicit receiver）
![picture 5](images/ec3107d5f599f09ce700ba3037e0e78823c1d106e57376efaec40cf313b09393.png)  

### 适用性
- 有多个对象可以处理同一个请求，哪一个对象处理该请求运行时自动确定
- 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求

### 结构
![picture 6](images/1ba61067726ae11789f8e39c0cb41f51b9c4762f5c3c627e83cf1b81d3b5eaea.png)  

### 参与者
- handler： 定义一个处理请求的接口，实现后继链
- concreteHandler: 处理请求，访问后继者，处理或转发
- client： 向链上的具体处理者对象提交请求

### 效果
- 降低耦合度，无需知道哪一个对象处理请求
- 增强了指派职责的灵活性： 可以动态的增加或修改请求的职责
- 不保证被接受

### 相关模式
- 常常和composite一起使用，将父构件作为它的后继
## command 命令
### 意图
- 将一个请求封装成一个对象，从而可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作

### 动机
- 有时必须向某对象提交请求，但并不知道关于被请求的操作或请求接收者的任何信息
- 通过将请求本身变成一个对象来使工具箱对象可向未指定的应用对象提出请求。
- 抽象的command类，定义了一个execute执行操作的接口

![picture 7](images/51f543e62c597bf5a808c9f59aa35fd11e0d0233d231ef5354ce3e8254e0506d.png)  
![picture 8](images/c47de8d00174a5a99fdbfd9947f1736f88f2091787aa26f5a44dd0caf54fce66.png)  
### 适用性
- 抽象出待执行的动作以参数化某对象，callback： 函数现在某处注册，他将在稍后某个需要的时候调用，command是回调机制一个面向对象的替代品
- 在不同时刻指定，排列和执行请求，command有一个与初始请求无关的生存期
- 支持取消操作，unexecute操作
- 支持修改日志
- 用构件在原语操作上的高层高作构造一个系统。 在支持事务（transaction）的信息系统中很常见。

### 结构
![picture 9](images/c586c410c985add4edfd5b67d8bc7048db255499db564cdecfd2e2ab83d3e02e.png)  

### 参与者
- command： 执行操作的接口
- concretecommand：将一个接收者对象绑定于一个动作
- client： 创建一个具体命令对象并设定他的接收者
- invoker： 要求该命令执行这个请求
- receiver： 知道如何实施一个请求相关的操作

### 协作
-  client创建一个concretecommand对象并制定他的receiver对象
-  某invoker对象存储该concretecommand对象
-  invoker调用command对象的execute操作来提交一个请求
-  concretecommand对调用他的receiver执行一些操作

### 效果
- 将调用操作的对象和知道如何实现操作的对象解耦
- command可以被扩展和操纵
- 可以将多个命令装配成一个命令
- 增加新的command很简单

### 相关模式
- composite模式 用来实现宏命令
- memento： 保持某个状态
## interpreter 解释器
## iterator 迭代器
## mediator 中介者
### 意图
- 用一个中介对象来封装一系列的对象交互。中介者使个对象不需要显式的相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互
### 动机
- 对象之间可能有很多链接，最坏情况下，每一个对象都知道其他所有对象，不得不定义很多子类以定制系统的行为
- 将集体行为封装在一个单独的中介者对象中，中介者控制和协调一组对象之间的交互，是的组中的对象不再相互显式引用，对象仅知道中介者（组件通信的中转中心）

### 适用性
- 一组对象定义良好但通信复杂
- 一个对象引用很多对象并直接与这些对象通信
- 想定制一个分布在多个类的行为，而不想生成太多子类

### 结构
![picture 1](images/53e32e7d07223368e4b803c58314883e733e210060e6d1e9e9dbb8d81d342e8c.png)  

### 参与者
- mediator： 中介者定义一个接口用于和同事对象通信
- concretemediator： 具体中介者协调各同事对象
- colleague class： 每一个同事类都知道他的中介者对象，对象在与其他同事通信时，与他的中介者通信

### 协作
- 同事向中介者发送和接收请求，中介者适当的转发请求

### 效果
- 减少子类生成
- 解耦colleague
- 简化了对象协议
- 抽象了对象如何协作
- 使控制集中化

### 相关模式
- colleague可使用observer模式与mediator通信
## memento 备忘录
## observer 观察者
### 意图
- 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并自动更新

### 动机
- 维护相关对象间的一致性，同时不希望使各类紧密耦合
- 用户改变表格信息，柱状图和表格都能同时反映变化
- 目标（object) 和观察者（observer），一旦目标的状态发生改变，所有的观察者都得到通知，也称为发布-订阅（publish-subscribe）

### 适用性
- 一个抽象对象有两个方面，其中一个方面依赖于另一个方面，这两个对象封装在独立的对象中使他们可以各自独立的改变和复用
- 当一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变
- 当一个对象必须通知其他对象，而不知道有多少对象有待改变

### 结构
![picture 2](images/e2460d273e9d87e1ae4a367ee7a7ea83086e6f8ea641d3e85ccf6a1781a5778e.png)  

### 参与者
- subject（目标）： 目标知道他的观察者，可以有任意多个观察者观察同一个目标
- observer(观察者)： 为那些在目标发生改变时需要获得通知的对象定义一个更新接口
- concretesubject（具体目标）： 将有关状态存入各concreteobserver对象
- concreteobserver(具体观察者)： 维护一个指向concretesubject对象的引用，存储有关状态，实现observer更新接口

### 协作
- 当concretesubject发生任何可能导致其观察者与其本身状态不一致的变化时，他将通知它的各个观察者
- 在得到一个具体目标的改变通知后，concreteobserver 对象可向目标对象查询信息。concreteobserver使用这个信息使它的状态与目标对象的状态一致。
- 发出改变对象的observer对象并不立即更新，而是推迟到他从目标得到一个通知之后
- notify不总是由目标对象调用，他可以被一个观察者或其他对象调用

### 效果
- 目标与观察者的抽象耦合，目标不知道任何一个观察者属于哪一个具体的类
- 支持广播通信，不需要知道接收者
- 意外的更新，一个观察者不知道其他观察者的存在

### 相关模式
- mediator： changemanager 充当目标与观察者之间的中介
- singleton： changemanager可使用singleton模式来保证他是唯一的并且可以全局访问
## state 状态
## strategy 策略
## template method 模板方法

### 意图
- 定义一个操作中的算法骨架，从而将一些步骤延迟到子类中
- 使子类可以不改变一个算法的结构就重定义改算法的某些步骤

### 意图
![picture 3](images/aa3405f91c15d0a98cbfd001180ae78abb37da34900f5f534c3759dbc21a7a4e.png)  

- 用一些抽象的操作定义一个算法，子类重定义这些操作以提供具体的行为

### 适用性
- 一次性实现一个算法不变的部分，将可变的行为留给子类
- 各子类公共的行为提取出来到一个公共弗雷避免代码重复
- 控制子类扩展

### 结构
![picture 4](images/2c9b8c71269b0e87bc7ae78704b240b39e677f5993bca1e4aabcd9be083d97c3.png)  

- abstractclass： 定义抽象的原语操作
- concreteclass: 实现原语操作以完成算法与特定子类相关的步骤

### 协作
- concreteclass靠abstractclass实现算法不变的步骤
- hook operation： 提供缺省的行为，子类可以在必要时进行扩展

### 相关模式
- factory method： 常被模板方法调用
- strategy： 模板方法使用继承来改变算法的一部分，strategy使用委托来改变整个算法
## visitor 访问者

### 意图
- 表示一个作用域某对象结构中各元素的操作。他使可以在不改变各元素的类的前提下定义作用域这些元素的新操作

### 动机
- 编译器将程序表示为抽象语法树
![picture 5](images/8360042255f02a2882b2a4fa6d36cd12cae7c19ec06e11bf7b73b26d436a2627.png)  

- 可以独立增加新的操作，使这些节点类独立作用与其上的操作
- 将每一个类中相关的操作包装在一个独立对象中（visitor）
- 当一个元素接收访问者时，元素向访问者发送一个包含自身类信息的请求
- 请求将元素本身作为一个参数，执行该操作
![picture 6](images/d31cf531ce5adb5772a7d3dd50ed4acafb1ff4a53670d04e9016dfd762c554f7.png)  

- 两个类层次，一个对应于接收操作的元素（Node层次），一个对应定义对元素的操作的访问者（NodeVisitor）层次。

### 适用性
- 一个对象结构包含很多对象，他们有不同接口，而对这些对象实施一些以阿里与其具体类的操作
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作
- 定义对象结构的类很少发生改变，但经常要在此结构上定义新的操作

### 结构
![picture 7](images/3e459744532cdec19cb9edeaafa0aa769498e26d143b8361ef7d7d9686a5776d.png)  

### 参与者
- visitor，访问者 为该对象结构中concreteelement的每一个类声明一个visit操作，标识了发送visit请求给访问者哪个类
- concretevisitor 实现每个visitor声明的操作，为算法提供了上下文并存储了它的局部状态
- element：元素 定义一个accept操作，以一个访问者为参数
- concreteelement： 实现accept操作
- objectstructure：对象结构  能枚举它的元素，提供一个高层接口以允许访问者访问它的元素，可以是一个复合或者集合

### 协作
- 一个visitor模式的客户必须创建一个concretevisitor对象然后遍历改对象结构，用该访问者访问每一个元素
- 当一个元素被访问时，他调用对应他类的visitor操作

![picture 8](images/1972f27cdc3356105c5ce8ff8ac24a4e618ae507ab6397900f65d0fe807dd801.png)  

### 效果
- 易于增加新的操作
- 访问者集中相关的操作，分离无关的操作
- 增加新的concreteelement 很困难
- 通过类层次来进行访问，可以访问不具有相同父类的对象
- 积累状态
- 破坏封装，迫使提供访问元素内部状态的公共操作
